# kubectl로 Pod 생성 시 Master/Worker Node 흐름

## 전체 아키텍처 개요

```
┌─────────────────────────────────────────────────────────────┐
│                        Master Node                          │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │ API Server  │  │  Scheduler   │  │Controller Manager│   │
│  └─────────────┘  └──────────────┘  └──────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                    etcd                             │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                        Worker Node                          │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │   kubelet   │  │  kube-proxy  │  │Container Runtime │   │
│  └─────────────┘  └──────────────┘  │  (containerd)    │   │
│                                     └──────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 단계별 상세 흐름

### STEP 1 — kubectl 요청 (클라이언트)

```
사용자 → kubectl apply -f pod.yaml
```

- kubectl은 `~/.kube/config`에서 **인증 정보 + API Server 주소** 를 읽음
- YAML을 JSON으로 변환 후 **HTTPS REST 요청** 전송
- `POST /api/v1/namespaces/default/pods`

---

### STEP 2 — API Server (Master) 수신 및 검증

```
kubectl ──HTTPS──→ kube-apiserver
```

1. **Authentication (인증)**: 클라이언트 인증서 / 토큰 검증
2. **Authorization (인가)**: RBAC 정책으로 해당 유저가 Pod 생성 권한 있는지 확인
3. **Admission Control**: MutatingWebhook → ValidatingWebhook 순서로 실행
   - 기본값 주입 (default resource limits 등)
   - 정책 위반 여부 검사
4. **Validation**: Pod 스펙 형식 유효성 검사

---

### STEP 3 — etcd에 상태 저장 (Master)

```
kube-apiserver ──→ etcd
```

- 검증 통과 후 Pod 오브젝트를 **etcd에 저장**
- 이 시점의 Pod 상태: `Pending` (nodeName 없음)
- etcd는 **클러스터의 단일 진실 공급원(Source of Truth)**

```yaml
# etcd에 저장되는 Pod 상태
status:
  phase: Pending
spec:
  nodeName: ""   # 아직 스케줄 안 됨
```

---

### STEP 4 — Scheduler가 Node 선택 (Master)

```
kube-scheduler ──Watch──→ API Server (nodeName="" 인 Pod 감지)
```

**Filtering (필터링)** — 불가능한 노드 제거:
| 필터 | 설명 |
|------|------|
| `NodeResourcesFit` | CPU/메모리 요청량 충족 여부 |
| `NodeAffinity` | affinity 규칙 일치 여부 |
| `TaintToleration` | taint 허용 여부 |
| `NodePorts` | 포트 충돌 여부 |

**Scoring (점수화)** — 최적 노드 선택:
| 점수 기준 | 설명 |
|-----------|------|
| `LeastAllocated` | 자원 사용량이 적은 노드 선호 |
| `InterPodAffinity` | Pod 간 친화성 |
| `ImageLocality` | 이미 이미지 가진 노드 선호 |

- 최고 점수 노드를 선택 → **API Server에 `nodeName` 업데이트 요청**

---

### STEP 5 — kubelet이 Pod 감지 (Worker)

```
kubelet ──Watch──→ API Server (자신의 노드로 할당된 Pod 감지)
```

- 각 Worker의 **kubelet**은 API Server를 지속적으로 Watch
- `nodeName == 자신의 노드명` 인 Pod 발견 시 동작 시작
- **PodSpec을 로컬에서 실현(Reconcile)** 하는 역할

---

### STEP 6 — 컨테이너 런타임 호출 (Worker)

```
kubelet → CRI (Container Runtime Interface) → containerd → runc
```

```
kubelet
  └─→ CRI 호출 (gRPC)
        └─→ containerd
              ├─→ 이미지 Pull (없는 경우)
              │     └─→ Registry (Docker Hub 등)
              ├─→ 네트워크 설정 (CNI 플러그인 호출)
              │     └─→ Calico / Flannel / Cilium 등
              └─→ runc (실제 컨테이너 생성)
                    ├─→ Linux Namespace 생성 (pid, net, mnt...)
                    └─→ cgroup 설정 (CPU/메모리 제한)
```

---

### STEP 7 — 상태 업데이트 및 완료 (Worker → Master)

```
kubelet ──→ API Server ──→ etcd
```

- kubelet이 주기적으로 **컨테이너 상태를 API Server에 보고**
- Pod 상태 전이:

```
Pending → ContainerCreating → Running
```

- `kube-proxy`는 Service가 있는 경우 **iptables / ipvs 규칙** 업데이트

---

## 전체 흐름 타임라인

```
시간 →
  [0ms]   kubectl → API Server 요청
  [10ms]  API Server: 인증/인가/검증
  [20ms]  etcd 저장 (Pending)
  [50ms]  Scheduler: 노드 선택 완료
  [60ms]  kubelet: Pod 할당 감지
  [100ms] 이미지 Pull 시작 (캐시 있으면 스킵)
  [N초]   이미지 Pull 완료
  [N+1초] 컨테이너 생성 (runc)
  [N+2초] Pod Running 상태 보고
```

---

## 핵심 요약

| 구성요소 | 위치 | 역할 |
|----------|------|------|
| `kube-apiserver` | Master | 모든 요청의 진입점, 유일한 etcd 접근자 |
| `etcd` | Master | 클러스터 상태 영속 저장 |
| `kube-scheduler` | Master | 어느 노드에서 실행할지 결정 |
| `controller-manager` | Master | 선언적 상태 유지 (ReplicaSet 등) |
| `kubelet` | Worker | Pod 스펙을 실제 컨테이너로 구현 |
| `kube-proxy` | Worker | 네트워크 규칙(iptables) 관리 |
| `container runtime` | Worker | 실제 컨테이너 실행 (containerd) |

> **핵심 원칙**: 모든 컴포넌트는 **API Server만 직접 통신**하며, etcd는 API Server만 접근합니다. 이 설계 덕분에 느슨한 결합(loose coupling)과 확장성이 보장됩니다.
