# Kubernetes Affinity - CKA 실전 문제 스타일 예제

---

## 1. Affinity란?

Pod가 **어느 노드에 스케줄링될지**를 제어하는 규칙입니다.
기본 `nodeSelector`보다 훨씬 유연한 표현이 가능합니다.

---

## 2. 종류 (3가지)

| 종류 | 대상 | 설명 |
|------|------|------|
| **Node Affinity** | Pod → Node | 특정 노드에 Pod를 배치 |
| **Pod Affinity** | Pod → Pod | 특정 Pod와 같은 노드/존에 배치 |
| **Pod Anti-Affinity** | Pod → Pod | 특정 Pod와 다른 노드/존에 배치 |

---

## 3. Node Affinity

### 두 가지 타입
```
requiredDuringSchedulingIgnoredDuringExecution  ← 필수 (하드)
preferredDuringSchedulingIgnoredDuringExecution ← 선호 (소프트)
```

> `IgnoredDuringExecution` = 이미 실행 중인 Pod는 영향 없음

### 예시 YAML
```yaml
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: disktype
            operator: In
            values:
            - ssd
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1          # 1~100, 높을수록 우선
        preference:
          matchExpressions:
          - key: region
            operator: In
            values:
            - us-east
```

### Operator 종류
| Operator | 설명 |
|----------|------|
| `In` | values 중 하나 포함 |
| `NotIn` | values 중 없음 |
| `Exists` | 키가 존재 |
| `DoesNotExist` | 키가 없음 |
| `Gt` / `Lt` | 숫자 비교 |

---

## 4. Taint & Toleration과의 차이점

```
Node Affinity  = Pod가 노드를 "선택"  (Pod 입장)
Taint          = 노드가 Pod를 "거부"  (Node 입장)
Toleration     = Pod가 Taint를 "허용" (Pod 입장)
```

**두 가지를 함께 쓰면** 특정 노드에 특정 Pod만 배치하는 완전한 격리가 가능합니다.

---

## 문제 1: Node Affinity (required)

### 문제
> `web-pod`라는 Pod를 생성하세요.
> - image: `nginx`
> - **반드시** `disktype=ssd` 라벨이 있는 노드에만 스케줄링되어야 합니다.
> - `ssd` 또는 `nvme` 값 모두 허용합니다.

### 정답 YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-pod
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:  # ← 필수 조건
        nodeSelectorTerms:
        - matchExpressions:
          - key: disktype          # ← 노드 라벨의 key
            operator: In           # ← values 중 하나라도 일치하면 OK
            values:
            - ssd
            - nvme
  containers:
  - name: web
    image: nginx
```

### 옵션 상세 설명

| 옵션 | 값 | 설명 |
|------|----|------|
| `requiredDuringSchedulingIgnoredDuringExecution` | - | **스케줄링 시 필수**. 조건 만족 노드가 없으면 Pod는 `Pending` 상태로 대기 |
| `IgnoredDuringExecution` | - | 이미 실행 중인 Pod는 노드 라벨이 바뀌어도 **퇴출되지 않음** |
| `nodeSelectorTerms` | 배열 | 여러 항목은 **OR** 조건. 하나라도 만족하면 스케줄링 |
| `matchExpressions` | 배열 | 같은 term 안에서는 **AND** 조건. 모두 만족해야 함 |
| `key` | `disktype` | 노드에 붙은 라벨의 key |
| `operator: In` | - | `key`의 값이 `values` 목록 중 하나여야 함 |
| `values` | `[ssd, nvme]` | 허용할 라벨 값 목록 |

---

## 문제 2: Node Affinity (preferred + weight)

### 문제
> `app-pod`를 생성하세요.
> - image: `redis`
> - `region=us-east` 노드를 **선호**하되, 없으면 다른 노드에도 배치 가능합니다.
> - `env=production` 노드는 더 높은 우선순위(weight: 80)로 선호합니다.

### 정답 YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:  # ← 선호 조건
      - weight: 20                    # ← 우선순위 점수 (낮음)
        preference:
          matchExpressions:
          - key: region
            operator: In
            values:
            - us-east
      - weight: 80                    # ← 우선순위 점수 (높음)
        preference:
          matchExpressions:
          - key: env
            operator: In
            values:
            - production
  containers:
  - name: app
    image: redis
```

### 옵션 상세 설명

| 옵션 | 값 | 설명 |
|------|----|------|
| `preferredDuringSchedulingIgnoredDuringExecution` | - | **선호 조건**. 만족 노드가 없어도 Pod는 정상 스케줄링됨 |
| `weight` | `1~100` | 점수가 높을수록 우선 선택. 스케줄러가 각 노드의 weight를 합산해 가장 높은 노드 선택 |
| `preference` | - | `required`의 `matchExpressions`와 동일한 구조 |
| 복수 preferred 항목 | - | 스케줄러가 **모든 weight를 합산** → 총점 높은 노드 선택 |

> **점수 계산 예시**
> ```
> Node A: region=us-east, env=production → 20 + 80 = 100점
> Node B: env=production                 → 0  + 80 = 80점
> Node C: region=us-east                 → 20 + 0  = 20점
> Node D: 아무것도 없음                  → 0        = 0점
> → Node A에 스케줄링됨
> ```

---

## 문제 3: Pod Anti-Affinity (HA 구성)

### 문제
> `Deployment`를 생성하세요.
> - name: `ha-app`, replicas: `3`, image: `httpd`
> - 각 Pod는 **반드시 서로 다른 노드**에 배치되어야 합니다. (고가용성)

### 정답 YAML

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ha-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ha-app
  template:
    metadata:
      labels:
        app: ha-app           # ← Anti-Affinity가 이 라벨을 기준으로 판단
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                app: ha-app   # ← 나와 같은 라벨을 가진 Pod와
            topologyKey: kubernetes.io/hostname  # ← 같은 노드(hostname)에는 배치 금지
      containers:
      - name: app
        image: httpd
```

### 옵션 상세 설명

| 옵션 | 값 | 설명 |
|------|----|------|
| `podAntiAffinity` | - | 지정한 Pod와 **같은 토폴로지에 배치 금지** |
| `labelSelector` | - | 회피할 대상 Pod를 라벨로 선택 |
| `matchLabels` | `app: ha-app` | 이 라벨을 가진 Pod와 같은 위치를 피함 (자기 자신 포함) |
| `topologyKey` | `kubernetes.io/hostname` | 비교 단위. `hostname` = 노드 단위로 분리 |
| `topologyKey` | `topology.kubernetes.io/zone` | 가용 영역(AZ) 단위로 분리 |

> **주의:** `required`로 설정 시 노드 수 < replicas 수 이면 일부 Pod가 `Pending`

---

## 문제 4: Pod Affinity + Anti-Affinity 혼합

### 문제
> `cache-pod`를 생성하세요.
> - image: `memcached`
> - `app=frontend` 라벨 Pod와 **같은 노드**에 배치 (캐시 성능 최적화)
> - `app=cache` 라벨 Pod와는 **다른 노드**에 배치 (중복 방지)

### 정답 YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cache-pod
  labels:
    app: cache
spec:
  affinity:
    podAffinity:                        # ← frontend와 같은 노드에
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app: frontend
        topologyKey: kubernetes.io/hostname
    podAntiAffinity:                    # ← 다른 cache pod와 다른 노드에
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app: cache
        topologyKey: kubernetes.io/hostname
  containers:
  - name: cache
    image: memcached
```

---

## 전체 구조 한눈에 보기

```
spec.affinity
├── nodeAffinity
│   ├── requiredDuringSchedulingIgnoredDuringExecution
│   │   └── nodeSelectorTerms[]          ← OR
│   │       └── matchExpressions[]       ← AND
│   │           ├── key
│   │           ├── operator (In/NotIn/Exists/DoesNotExist/Gt/Lt)
│   │           └── values[]
│   └── preferredDuringSchedulingIgnoredDuringExecution
│       ├── weight (1~100)
│       └── preference.matchExpressions[]
│
├── podAffinity
│   └── required... / preferred...
│       ├── labelSelector.matchLabels / matchExpressions
│       └── topologyKey  ← 필수!
│
└── podAntiAffinity
    └── (podAffinity와 동일한 구조)
```

---

## 시험장 체크리스트

```bash
# 1. 노드 라벨 확인
kubectl get nodes --show-labels

# 2. 라벨 추가 (문제에서 요구할 수 있음)
kubectl label node node01 disktype=ssd

# 3. 적용 후 확인
kubectl get pod -o wide
kubectl describe pod <pod-name>  # Events에서 스케줄링 실패 원인 확인

# 4. 빠른 YAML 생성 후 수정
kubectl run web-pod --image=nginx --dry-run=client -o yaml > pod.yaml

# 5. 필드 구조 확인
kubectl explain pod.spec.affinity.nodeAffinity --recursive
```

> **시험 꿀팁:** `kubectl explain pod.spec.affinity.nodeAffinity --recursive` 로 필드 구조를 시험장에서 바로 확인 가능!
